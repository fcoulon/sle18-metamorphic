\pdfminorversion=5
\pdfobjcompresslevel=2

\RequirePackage[l2tabu, orthodox]{nag}

\documentclass[sigplan]{acmart}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{microtype}
\usepackage{listings}
\usepackage{color}
\usepackage{xspace}
\usepackage{balance}
\usepackage{todonotes}
\usepackage[all]{nowidow}
\usepackage{tikz}
\usepackage[scaled]{beramono}
\usepackage{booktabs}
%\usepackage[bookmarks=false,colorlinks=true,allcolors=black,breaklinks]{hyperref}
\usepackage{cleveref} % Keep me last so that I can
                      % reset other counters
                      
\newtheorem{definition}{Definition}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}

% DOI
%\acmDOI{10.475/123_4}

% ISBN
%\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[SLE'18]{International Conference on Software Language Engineering}{November 2018}{Boston, MA, USA}
\acmYear{2018}
\copyrightyear{2018}

\acmPrice{15.00}

%\acmBadgeL[http://ctuning.org/ae/ppopp2016.html]{ae-logo}
%\acmBadgeR[http://ctuning.org/ae/ppopp2016.html]{ae-logo}

\hypersetup{%
	pdftitle={},
	pdfauthor={},
	pdfkeywords={}
}

\input{commands}

\newboolean{CommentON}
\setboolean{CommentON}{true} % to disable the comments set CommentON to false in the main doc

\begin{document}
\title{``\emph{Free the languages!}''}
%\titlenote{Models are synchonized, not DSLs, though}
\subtitle{Language Engineering across Technological Boundaries}
%\subtitlenote{The full version of the author's guide is available as
%		\texttt{acmart.pdf} document}

\author{ALE}
%\authornote{Dr.~Trovato insisted his name be first.}
%\orcid{1234-5678-9012}
\affiliation{%
	\institution{ALE}
%	\streetaddress{P.O. Box 1212}
%	\city{Dublin}
%	\state{Ohio}
%	\postcode{43017-6221}
}
\email{ale@ale.org}

% The default list of authors is too long for headers.
%\renewcommand{\shortauthors}{B. Trovato et al.}

\input{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
 \begin{CCSXML}
	<ccs2012>
	<concept>
	<concept_id>10011007.10011006.10011050.10011017</concept_id>
	<concept_desc>Software and its engineering~Domain specific languages</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
	</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Domain specific languages}

%\keywords{domain-specific language, metamorphic dsl, language workbenches}

%\begin{teaserfigure}
%	\includegraphics[width=\textwidth]{sampleteaser}
%	\caption{This is a teaser}
%	\label{fig:teaser}
%\end{teaserfigure}

\maketitle

\section{Introduction \& Motivating Example}
One of the first steps in designing a new DSL is to choose the \emph{language vehicle} within which it will be engineered.
We define a language vehicle (LV) as the technological means for implementing a language.
%A language vehicle may pertain to any \emph{technological space} (TS) such as grammarware, modelware, PLware, \etc.
The distinction between language vehicles is orthogonal to the distinction between \emph{technological spaces} (\eg~grammarware, modelware, PLware);\footnote{In this paper, we build upon \citeauthor{kurtev2002technological}'s view of a TS:~``a working context with a set of associated concepts, body of knowledge, tools, required skills, and possibilities''~\cite{kurtev2002technological}} the distinction between graphical and textual syntaxes; the distinction between internal, embedded, and external DSLs, \etc.
%In addition, we consider a cohesive set of tools in a given TS (\eg~a particular language workbench) as a separate TS.
For instance, following this definition, we view Rascal and Spoofax as two distinct language vehicles within the broader TS of grammarware and meta-programming, and EMF and UML (through Profiles) as two distinct language vehicles within the broader TS of modelware.
LVs usually come with their own meta-languages for expressing the various aspects of a DSL:~abstract syntax, concrete syntax, static and execution semantics, \etc.
Examples of prominent LV include meta-modeling environments such as EMF~\cite{steinberg2008emf}, meta-programming environments such as Rascal~\cite{klint2010easy} and Spoofax~\cite{kats2010spoofax}, projectional environments such as MPS~\cite{voelter2013language}, plain old programming languages such as Racket~\cite{felleisen2018programmable} or Scala~\cite{hofer2010modular}, and language workbenches (LWBs) in general~\cite{erdweg2015evaluating}'.
As implementation techniques radically differ from one LV to the other, this initial design choice commits the development of a DSL in a set direction that can hardly be reconsidered later on.

From a language designer's point of view, however, every TS comes with its unique strengths.
The ecosystem around EMF excels in the definition of, for instance, graphical editors and persistence frameworks for large models, while the Rascal language excels in the definition of, for instance, interpreters and refactoring tools.
%On the other hand, the flexibility of manipulating the concepts of a DSL through a fluent API, using the capabilities of a general-purpose programming language, is unmatched.
The benefits of various TS are also visible from the language users' point of view.
While domain experts may prefer to manipulate the domain concepts through a dedicated syntax (graphical, textual, or a mix thereof), advanced users may favor the flexibility of a fluent API in their favorite programming language to manipulate the very same abstractions.
As of today, however, it is hardly possible to combine the strengths of multiple TS to engineer a single DSL.

Let us consider a simple finite-state machine (FSM) language as a motivating example.
As depicted in \Cref{fig:motivating-fsm}, one would like to combine the strengths of multiple TS to engineer this DSL.
Rascal could be used to develop its interpreter, a set of refactoring tools (\eg~collapsing, minimization), and a textual editor; EMF to develop a graphical editor and animator of running FSM models; and Java to offer a fluent API for advanced users who focus on its integration within a broader system.
Using today's techniques, it is entirely possible to define the same FSM language with the aforementioned tools in these three TS.
There is currently no way, however, to apply the tools of a given TS on the models created in another TS---for instance, animating a FSM model written in EMF using the Rascal interpreter, or synchronizing a textual FSM model in Rascal with its equivalent incarnation in the form of a fluent API calls in Java.
Achieving this goal requires to synchronize the diverse in-memory representation of the same model in different TS; for instance to allow the Rascal interpreter to update its in-memory representation of an FSM model and synchronize it with the in-memory representation of the same model in EMF so that the animation works. Argh.

In this paper, we envision a language engineering activity where language designers combine tools from multiple vehicles to engineer a single DSL.
Thus, we endeavor to show \emph{how to break down the barriers between different vehicles so that language designers can benefit from the strengths of each in the engineering of a single DSL, and language users can synchronize their models across various shapes}.
\emph{Metamorphic synchronization} refers to the possibility of synchronizing different incarnations of the same model in different shapes of a language, \ie~in different vehicles.
As different vehicles rely on radically different fundamental theories, a successful approach for bridging them must thus \emph{align} (!no!) them in some way.
We investigate this question in the next section.

\begin{figure}
	\centering
	\includegraphics[width=\columnwidth]{figures/motivating-fsm}
	\caption{Shapes of an FSM language}
	\label{fig:motivating-fsm}
\end{figure}

\section{Incremental Synchronization of Metamorphic DSLs}
\td{\emph{Our} simple impl., \emph{our} patch formalism, \emph{our} dispatch, \etc}
The cornerstone artifact defining a DSL in any TS is its abstract syntax.
The way abstract syntax is expressed differs drastically from one LWB to another: Xtext\footnote{\url{https://www.eclipse.org/Xtext/}} and GEMOC~\cite{bousse2016execution} use Ecore metamodels~\cite{steinberg2008emf}; Spoofax~\cite{kats2010spoofax} uses SDF grammars~\cite{heering1989syntax}; MPS\footnote{\url{https://www.jetbrains.com/mps/}} uses \emph{concepts}; Rascal~\cite{klint2010easy} uses Algebraic Data Types (ADT); \etc.
Language embedding techniques, on the other hand, use the constructs of an host language to materialize the abstractions of a DSL in the host language itself.
In all models, concrete models are then built as instances of the corresponding abstract syntax formalism:~Ecore models, ADT values, Java constructs, \etc.
The tools defined within a given TS (\eg~an interpreter in Rascal, an editor in EMF) manipulate models in the appropriate formalism (\eg, respectively, ADT values and Ecore models).

A naive way to bridge these TS would be to define bidirectional transformations between the AS formalisms of every pair $\langle TS, TS' \rangle$.
Doing so however would break \emph{incrementality}, \ie~it would not be possible to maintain the extra information every TS holds, such as layout in a editor or runtime data when running models.
In our approach, instead, every change occuring on one side is shipped to all the other sides.
The latter then decide which parts of the changes they want to take into account.
An outline, for instance, would probably ignore most of the changes and focus on some of them. Argh.

Bridging multiple TS thus requires to ``align'' in some ways the representation of the AS of a language in these different TS.
As an illustration, the EMF and the Rascal LWB expose fundamental differences:~object-oriented vs. functional, graphs vs. trees, mutable ASG vs. immutable ASTs, cross-references vs. symbolic names, \etc.
However, it is neither possible nor desirable to establish a common formalism upon which various TS would agree:~mapping those is out of reach.

The key underlying idea of our approach is to provide the capability, at any time, to ``project'' a given model in any of its shapes and to synchronize those shapes whenever one of them is updated.
We enable the projection of a given model as an ADT value, to be manipulated in the Rascal TS, or as an Ecore model, to be manipulated in the EMF TS.

Instead, our approach keeps the TS fully independent and builds a communication bus between them.
Both representations of the same model in various TS are kept in memory to allow online synchronization of the same models manipulated by different stakeholders in different shapes.
When a changes occurs on either side, this side is responsible for generating a \emph{patch} (aka. \de or edit script~\cite{rozen2017towards}), that stores the changes on the model that have been realized on this side.
The communication bus then ships this patch to all the other sides.
Every side interprets the patch in its own way to keep the representation synchronized.
On the EMF side, for instance, the patch is interpreted as a set of changes that impact an Ecore model, while on the Rascal side it is interpreted as a set of changes that impact a value conforming to the ADT defining the AS of the language.

It is important to note that each TS may want to preserve certain information across the patches that are specific to the TS.
A textual editor in Rascal, for instance, needs to keep some of the parsing information to maintain layout whenever patches are applied.
So it should be possible to apply the patch while maintaining the extra information specific to a given TS.

Automatically generating language implementations in different TS is beyond the scope of this paper.\footnote{Indeed, this would actually require to build some kind of BX between all AS formalisms; so, nope!} Instead, given various shapes of a language, implemented by hand, we provide the means to automatically synchronize the projections of a model.

\begin{lstlisting}[label=lst:delta-adt, caption={CRUD-like \ds structure definition in Rascal}, language=Rascal]
@doc{A patch consists of a sequence of edits}
alias Patch = tuple[Id root, Edits edits];

@doc{Edits are operations attached to object identities}
alias Edits = lrel[Id obj, Edit edit];

data Edit
  = put(str field, value val)
  | unset(str field)
  | ins(str field, int pos, value val)
  | del(str field, int pos)
  | create(str class) 
  | destroy();
\end{lstlisting}

It is important to note that ``projections'' have no relation whatsoever with projectional editing.
A projection denotes the incarnation of a model in a particular shape of a language.
In \Cref{fig:motivating-fsm}, the lower part depicts three projections of the same \texttt{Button} state machine model in three shapes of the FSM language.
We use the term ``language'' to refer to the specification of a language independently from its realization in a given TS.
A concrete implementation of a language is a ``shape''.
An instance of a shape, \ie~a particular model in a particular TS, is a ``projection'' of a ``virtual'' model.
Metamorphic synchronization refers to the ability to synchronize the projections of a given model for every shapes of a language.

\begin{figure}
	\centering
	\includegraphics[width=.6\columnwidth]{figures/prism}
	\caption{A model projected in different Technological Spaces}
	\label{fig:prism}
\end{figure}

\begin{definition}
A technological space is a collection of tools and an environment defining a coherent space where users can design and use Languages.
\td{There's already a definition of TS that we should reuse (\cf footnote 1 page 1---\citeauthor{kurtev2002technological}~\cite{kurtev2002technological}}
\end{definition}

\begin{definition}
A projection of model is a relation between a conceptual model and its different incarnations in the technological spaces.
All of theses incarnations represent the same model but in different formalisms and technologies.
They are two necessary properties to have a model projection.
\begin{itemize}
	\item incarnations have to be in an equivalent \td{what does ``equivalent'' mean here?} states.
	\item incarnations have to be synchronized, i.e., any change on an incarnation is a change on the conceptual model and thus other incarnations have to apply the same change \td{Isn't that a duplicate of the previous point? Remove the first?}.
\end{itemize}
\end{definition}

\begin{definition}
The equivalence between the state of different incarnations is defined thanks to a Diff operation.
The Diff operation compare two states and output a description of the changes between them.
Two incarnations are in equivalent state if the Diff between a state and an empty state is equal for both incarnation.
Moreover for any change operation applicable to an incarnation, the two incarnations have to be in an equivalent state after the change.
\end{definition}

\begin{definition}
An incarnation is in the context of a model projection what is representing the model in a given technological space.
\end{definition}

\begin{definition}
A prism is the context of a model projection is the mechanism that allows the different incarnations of the model to be in equivalent state and to synchronize.
\end{definition}

\begin{definition}
A shape is a projection of a language in a particular technological space.
\td{Is it equivalent to the language \emph{implementation}?}
An incarnation of a model is conform to a shape of language if both are in the same technological space and if the model is conform to the language.
\end{definition}

\section{Shapes of an FSM Language}

\begin{figure}
	\centering
	\includegraphics[width=\columnwidth]{figures/concepts-instantiated}
	\caption{\dots}
	\label{fig:concepts-instantiated}
\end{figure}

\begin{figure*}[ht]
\begin{minipage}[b]{0.3\textwidth}
\begin{lstlisting}[label=lst:fsm-adt, caption={FSM in Rascal}, language=Rascal]
data Machine(Id uid = noId(), loc pkgURI = |http://www.example.org/myfsm|)
  = Machine(str name, list[State] states, Ref[State] initial = null());

data State(Id uid = noId())
  = State(str name, list[Trans] transitions);

data Trans(Id uid = noId())
  = Trans(str event, Ref[State] target);
\end{lstlisting}
\end{minipage}
\begin{minipage}[b]{0.3\textwidth}
\includegraphics[width=\textwidth]{figures/fsm-ecore.pdf}
\caption{FSM in Ecore}
\end{minipage}
\begin{minipage}[b]{0.3\textwidth}
\begin{lstlisting}[label=lst:fsm-api, caption={FSM in Fluent API}, language=Java]
class Fsm {
  Fsm(String name);
  State initial(String name);
  State state(String name);
  Fsm end();
}
class State {
  State state(String name);
  Transition target(String stateName);
  Fsm end();
}
class Transition {
  Transition target(String stateName);
  State on(String event);
  Fsm end();
}
%\end{lstlisting}
\end{minipage}
\end{figure*}

\subsection{Rascal}

The FSM language is defined in Rascal by the ADTs Machine, State and Trans.
A Machine has a name, contains a list of States and has a reference to an initial State.
States have a name and contains a list of Trans.
Trans is triggering an event and has a reference to an outgoing State.
The instantiation of any of theses types produce ADT values containing a unique identifier.
The containment references between ADT values are realised by lists of ADT values. But Rascal is a tree based language and there is no built in concept for simple reference.
The ADT Ref emulate this concept by containing an identifier equal to an identifier from an existing Machine,State or Trans.

\subsection{Ecore}

The same FSM language is defined by an Ecore metamodel containing the EClasses Machine, State and Trans.
Machine is the root container. It has an EAttribute ’name’, a containment EReference ’states’ typed State and a simple EReference ’initial’ typed State.
The EClass State has an EAttribute ’name’ and a containment EReference ’transitions’ typed Trans.
The EClass Trans has an EAttibutte ’event’ and a simple EReference ’target’ typed State.

\subsection{Java}

Another definition of the FSM language is done by a fluent Java API.
This shape allows to embed an Fsm model in a Java program by an expression starting with "new Fsm()" and ending with ".end()".
The API contains the classes Fsm, State and Transition.
The name of the Fsm is set by its constructor.
The reference to the initial state is expressed by the method initial taking the name of the referenced State as parameter.
The first contained States is added by method state() requiring a name as parameter.
The class State includes a method target() to add a contained Transition. It takes the name of a State as parameter to reference the outgoing State of the Transition.
By declaring the method state() too, the creation of States can be called in chain to fill the containing Fsm.
The class Transition add a method on() taking the name of an event to optionally set a triggering event on the transition.
Transition also provides the method target() to chain the creation of Transition in the containing State.

An API is fluent if it can be used in a way that looks like a program.
The FSM is represented as a sequence of method invocation.
The references are represented by argument of type String that allows the user to reference a State by its name.

As a fluent API is an embedded language, we need a mechanism to identified which range of a file is representing an FSM model.

A source of divergence with other Shapes of FSM is the encoding of the initial State.
We choose to represent a State by the method state() or by the method initial().
As the initial State is unique, we enforce its declaration as the first method invocation in the FSM. This solution solve the uniqueness but enforce the first state to be initial that it can be a source of divergence if models in other shape have a reference designating the initial state that is not in the first position. (if the order of State is part of the State Identifier)

The Java fluent API shape tends to break more easily the synchronization of their incarnations of models than the other shapes.
Indeed this shape of FSM language is an embedded language and has to rely on the host language for both the tooling and the expressiveness.
In the case of Java as host language, the validation service provided by the editor has no knowledge about the FSM language.
It makes harder for the user to detect mistakes such as typo. The FSM model can be in unnoticed dirty state and this can lead to the production of dirty Patches.
In the opposite the incarnation of the model can receive inapplicable Patches in this technological space.
For example in the Java TS, receiving a Patch telling to reference the second state of an FSM as the initial state is not possible due to the expressiveness of the API and this result in the desynchronization of the incarnation of the model.

The inconsistency of the incarnations of a model happen when one of them produce a dirty Patch or when one of them can't apply a Patch.

\section{Discussion \& Next Steps}
\td{If we write a vision paper, there must be a vision. Next steps? Roadmap? Challenges? What should the reader gain from reading this paper?}
\td{\eg It works here for 3 ``representative'' TS. What should you have in mind if you want to do that for others? What if you want to scale for collaborative/live modeling? \etc}
\begin{itemize}
	\item Our approach goes beyond what is described here. \eg synchronizing an outline view, a debugger, live modeling, w/e; also, we are AS-centric, but one could imagine something radically different;
	\item We don’t care how the list of changes is obtained. Diff is \emph{a} way to get there (as in the Rascal implementation), but obtaining the list of changes through other means (e.g., a transaction on a tree editor in EMF) is just as valid;
	\item Our dispatch is braindead. A better dispatch may enable collaborative editing, distributed synchronization, \etc;
	\item It may or may not be possible to automatically generate a shape from another. \eg~we did it for Ecore $\leftrightarrow$ Rascal;
	\item Transforming context-heavy Java ASTs is challenging; our tool is stupid in that respect; DIY;
	\item We do not really know if our patch formalism is sufficient; what if you want to plug another formalism; is there anything missing?
	\item \cite{lammel2005mappings}
	\item Delta/edit scripts are known (ref?), ``pivot'' formalisms are---infamously---known, we combine both in a new context; why? what do we get from that?
\end{itemize}

\clearpage
\balance
\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}
